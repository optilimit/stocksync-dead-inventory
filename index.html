<script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
        </script><!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>StockSync</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        body {
            font-family: 'Poppins', Arial, sans-serif;
            max-width: 800px;
            margin: 20px auto;
            padding: 15px;
            background-color: #f7fafc;
            color: #2d3748;
        }
        h1 {
            text-align: center;
            color: #2b6cb0;
            font-size: 1.8em;
            font-weight: 600;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 10px;
        }
        h1 i {
            color: #2b6cb0;
            font-size: 1.3em;
        }
        h3 {
            font-size: 1.1em;
            color: #2b6cb0;
            margin: 15px 0 8px;
        }
        .tool-description {
            text-align: center;
            color: #718096;
            font-size: 0.9em;
            margin-bottom: 20px;
        }
        .tooltip {
            position: relative;
            display: inline-block;
            cursor: help;
        }
        .tooltip .tooltiptext {
            visibility: hidden;
            width: 180px;
            background-color: #2d3748;
            color: #fff;
            text-align: center;
            border-radius: 4px;
            padding: 6px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            margin-left: -90px;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 0.8em;
        }
        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }
        .card {
            background-color: #ffffff;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            margin-bottom: 20px;
        }
        .input-group {
            margin-bottom: 12px;
        }
        .date-range-group {
            display: flex;
            gap: 10px;
            margin-bottom: 12px;
            flex-wrap: wrap;
        }
        .date-range-group .input-group {
            flex: 1;
            min-width: 150px;
        }
        label {
            font-weight: 500;
            color: #1a365d;
            font-size: 0.85em;
            margin-bottom: 4px;
            display: block;
        }
        input, select {
            padding: 8px;
            border: 1px solid #e2e8f0;
            border-radius: 5px;
            font-size: 0.9em;
            width: 100%;
            box-sizing: border-box;
            transition: border-color 0.2s;
        }
        input:focus, select:focus {
            outline: none;
            border-color: #4a90e2;
        }
        button {
            background: linear-gradient(to right, #4a90e2, #63b3ed);
            color: white;
            padding: 8px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.85em;
            width: 100%;
            transition: background 0.2s;
        }
        button:hover {
            background: linear-gradient(to right, #357abd, #4299e1);
        }
        .column-builder, .scenario-builder, .computed-field-builder, .condition-builder {
            margin-bottom: 15px;
        }
        .column-row, .scenario-row, .computed-field-row, .condition-row {
            display: flex;
            gap: 8px;
            margin-bottom: 10px;
            flex-wrap: wrap;
            align-items: center;
        }
        .column-row select, .column-row input,
        .scenario-row select, .scenario-row input,
        .computed-field-row input,
        .condition-row input {
            flex: 1;
            min-width: 100px;
        }
        .remove-btn {
            font-size: 1.2em;
            color: #e53e3e;
            cursor: pointer;
            background: none;
            border: none;
            padding: 2px 8px;
            line-height: 1;
            transition: color 0.2s;
        }
        .remove-btn:hover {
            color: #c53030;
        }
        .scenario-section {
            margin-top: 15px;
        }
        .scenario-list {
            margin-top: 10px;
        }
        .scenario-item {
            background: #edf2f7;
            padding: 8px 12px;
            border-radius: 5px;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.9em;
        }
        .scenario-item button {
            width: auto;
            padding: 5px 10px;
            font-size: 0.8em;
        }
        .results-section {
            margin-top: 15px;
            display: none;
        }
        .result-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9em;
        }
        .result-table th, .result-table td {
            border: 1px solid #e2e8f0;
            padding: 8px;
            text-align: center;
        }
        .result-table th {
            background: #e6f0fa;
            color: #2b6cb0;
            font-weight: 500;
        }
        .result-table .red {
            background: #fed7d7;
            color: #c53030;
        }
        .error {
            color: #e53e3e;
            font-size: 0.85em;
            text-align: center;
            margin-top: 10px;
        }
        .pattern-inputs, .range-inputs {
            display: flex;
            gap: 5px;
        }
        .pattern-inputs input {
            width: 50%;
        }
        .formula-input, .pattern-values {
            width: 100%;
        }
        @media (max-width: 600px) {
            body { padding: 10px; max-width: 100%; }
            .column-row, .scenario-row, .computed-field-row, .condition-row, .date-range-group {
                flex-direction: column;
            }
            .remove-btn { font-size: 1.1em; padding: 2px 6px; }
            .date-range-group .input-group { min-width: 100%; }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1><i class="fas fa-sync-alt"></i> StockSync</h1>
        <div class="tool-description">Create and test scenarios with probabilistic data to explore dead stock</div>
        <div class="card">
            <div class="column-builder">
                <h3>Step 1: Define Data Structure</h3>
                <div class="input-group">
                    <label for="row_count" class="tooltip">Number of Products<span class="tooltiptext">How many product rows to generate (1-1000)</span></label>
                    <input type="number" id="row_count" min="1" max="1000" placeholder="e.g., 100">
                </div>
                <div class="date-range-group">
                    <div class="input-group">
                        <label for="date_range_start" class="tooltip">Date Range Start<span class="tooltiptext">Earliest date for generated dates</span></label>
                        <input type="date" id="date_range_start">
                    </div>
                    <div class="input-group">
                        <label for="date_range_end" class="tooltip">Date Range End<span class="tooltiptext">Latest date for generated dates</span></label>
                        <input type="date" id="date_range_end">
                    </div>
                </div>
                <div id="columns"></div>
                <button id="add-column-btn">Add Column</button>
            </div>
            <div class="scenario-builder">
                <h3>Step 2: Define Scenario</h3>
                <div class="input-group">
                    <label for="scenario_name" class="tooltip">Scenario Name<span class="tooltiptext">Unique name for this scenario</span></label>
                    <input type="text" id="scenario_name" placeholder="e.g., Baseline">
                </div>
                <div class="input-group">
                    <label for="current_date" class="tooltip">Current Date<span class="tooltiptext">Date for calculations (e.g., today)</span></label>
                    <input type="date" id="current_date">
                </div>
                <div class="input-group">
                    <label for="product_id_col" class="tooltip">Product ID Column<span class="tooltiptext">Column with unique product identifiers</span></label>
                    <select id="product_id_col"></select>
                </div>
                <div class="input-group">
                    <label for="product_name_col" class="tooltip">Product Name Column<span class="tooltiptext">Column with product names</span></label>
                    <select id="product_name_col"></select>
                </div>
                <div id="scenario_patterns"></div>
                <button id="add-scenario-pattern-btn">Add Data Pattern</button>
            </div>
            <div class="computed-field-builder">
                <h3>Step 3: Define Computed Fields</h3>
                <div id="computed_fields"></div>
                <button id="add-computed-field-btn">Add Computed Field</button>
            </div>
            <div class="condition-builder">
                <h3>Step 4: Define Dead Stock Rules</h3>
                <div id="conditions"></div>
                <button id="add-condition-btn">Add Rule</button>
            </div>
            <div class="scenario-section">
                <button id="test-scenario-btn">Test Scenario</button>
                <div class="scenario-list" id="scenarioList"></div>
            </div>
            <div id="results" class="results-section">
                <button id="download-results-btn">Download Results (CSV)</button>
                <table class="result-table">
                    <thead>
                        <tr>
                            <th>Scenario</th>
                            <th>Product ID</th>
                            <th>Product Name</th>
                            <th>Dead Stock Count</th>
                            <th>Dead Stock Reason</th>
                        </tr>
                    </thead>
                    <tbody id="resultsBody"></tbody>
                </table>
            </div>
            <div id="error" class="error"></div>
        </div>
    </div>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            console.log('Script loaded, defining functions');

            const GOOGLE_FORM_URL = 'https://docs.google.com/forms/d/e/1FAIpQLSepL7Vn05g1RJtAMSIfOYs7mQcK4ZKZRRpD3OdeUzACMJVcIw/formResponse';
            const FORM_ENTRY_FIELD = 'entry.118636025'; // Updated to correct Entry ID

            let columns = [];
            let computedFields = [];
            let scenarioPatterns = [];
            let scenarios = [];

            function randomNormal(mean, sd) {
                const u1 = Math.random();
                const u2 = Math.random();
                const z0 = Math.sqrt(-2.0 * Math.log(u1)) * Math.cos(2.0 * Math.PI * u2);
                return z0 * sd + mean;
            }

            function parseChainedComparison(formula) {
                const chainedMatch = formula.match(/([\d.]+)\s*<\s*@([a-zA-Z_][a-zA-Z0-9_]*)\s*<\s*([\d.]+)/);
                if (chainedMatch) {
                    const [, lower, column, upper] = chainedMatch;
                    return `@${column} > ${lower} && @${column} < ${upper}`;
                }
                return formula;
            }

            function preprocessFormula(formula) {
                let processed = formula.replace(/@([a-zA-Z_][a-zA-Z0-9_]*)/g, '$1');
                processed = processed.replace(/\bor\b/gi, '||');
                processed = processed.replace(/\band\b/gi, '&&');
                return processed;
            }

            function validateFormulaColumns(formula, availableColumns) {
                const reservedWords = ['or', 'and', 'true', 'false', 'null', 'undefined', 'NaN'];
                const cleanFormula = preprocessFormula(formula);
                const columnsInFormula = cleanFormula.match(/[a-zA-Z_][a-zA-Z0-9_]*/g) || [];
                for (let col of columnsInFormula) {
                    if (!reservedWords.includes(col) && !availableColumns.some(c => c.name === col) && !col.startsWith('days_since_')) {
                        return `Formula references undefined column: ${col}`;
                    }
                }
                return null;
            }

            function evaluateFormula(formula, row, currentDate, availableColumns, fieldType = 'number') {
                try {
                    const parsedFormula = parseChainedComparison(formula);
                    const cleanFormula = preprocessFormula(parsedFormula);
                    const context = { ...row };
                    if (columns.some(c => c.type === 'date')) {
                        const currentDateObj = new Date(currentDate);
                        columns.forEach(col => {
                            if (col.type === 'date') {
                                const date = new Date(row[col.name]);
                                if (!isNaN(date.getTime()) && !isNaN(currentDateObj.getTime())) {
                                    context[`days_since_${col.name}`] = Math.round((currentDateObj - date) / (1000 * 60 * 60 * 24));
                                }
                            }
                        });
                    }
                    const validationError = validateFormulaColumns(parsedFormula, availableColumns);
                    if (validationError) throw new Error(validationError);
                    let safeFormula = cleanFormula.replace(/&&/g, '&&').replace(/\|\|/g, '||');
                    if (fieldType !== 'boolean') {
                        Object.keys(context).forEach(key => {
                            if (!isNaN(parseFloat(context[key])) && context[key] !== '') {
                                context[key] = parseFloat(context[key]);
                            }
                        });
                    }
                    const func = new Function(...Object.keys(context), `return ${safeFormula}`);
                    const result = func(...Object.values(context));
                    if (fieldType === 'boolean') {
                        return !!result;
                    }
                    return typeof result === 'number' ? result : !!result;
                } catch (e) {
                    throw new Error(`Invalid formula: ${e.message}`);
                }
            }

            async function saveToGoogleForm(jsonContent) {
                const errorDiv = document.getElementById('error');
                try {
                    // Encode JSON to prevent issues with special characters
                    const encodedJson = encodeURIComponent(jsonContent);
                    const formData = new FormData();
                    formData.append(FORM_ENTRY_FIELD, encodedJson);
                    console.log('Submitting form data:', FORM_ENTRY_FIELD, encodedJson);

                    const response = await fetch(GOOGLE_FORM_URL, {
                        method: 'POST',
                        body: formData,
                        mode: 'no-cors'
                    });
                    console.log('Data sent to Google Form successfully');
                    return true;
                } catch (e) {
                    console.error('Google Form submission error:', e.message);
                    errorDiv.textContent = `Failed to save to Google Form: ${e.message}. Ensure form accepts anonymous submissions. Downloaded JSON locally.`;
                    return false;
                }
            }

            function updateColumnSelectors() {
                console.log('updateColumnSelectors called');
                const errorDiv = document.getElementById('error');
                columns = Array.from(document.getElementsByClassName('column-row')).map(row => ({
                    name: row.querySelector('.column-name').value.trim(),
                    type: row.querySelector('.column-type').value
                })).filter(col => col.name);

                const columnNames = columns.map(col => col.name);
                const duplicates = columnNames.filter((name, index) => columnNames.indexOf(name) !== index);
                if (duplicates.length > 0) {
                    errorDiv.textContent = `Duplicate column names detected: ${duplicates.join(', ')}`;
                    return;
                }

                computedFields = Array.from(document.getElementsByClassName('computed-field-row')).map(row => ({
                    name: row.querySelector('.computed-field-name').value.trim(),
                    type: row.querySelector('.computed-field-type').value,
                    formula: row.querySelector('.computed-field-formula').value.trim()
                })).filter(field => field.name && field.formula);

                scenarioPatterns = Array.from(document.getElementsByClassName('scenario-row')).map(row => {
                    const column = row.querySelector('.pattern-column').value;
                    const type = row.querySelector('.pattern-type').value;
                    const pattern = { column, type };
                    if (type === 'normal') {
                        pattern.mean = row.querySelector('.pattern-mean')?.value.trim();
                        pattern.sd = row.querySelector('.pattern-sd')?.value.trim();
                    } else if (type === 'categorical') {
                        pattern.values = row.querySelector('.pattern-values')?.value.trim();
                    } else if (type === 'uniform') {
                        pattern.min = row.querySelector('.pattern-min')?.value.trim();
                        pattern.max = row.querySelector('.pattern-max')?.value.trim();
                    }
                    return pattern;
                }).filter(pattern => pattern.column);

                const selectors = ['product_id_col', 'product_name_col'];
                selectors.forEach(selector => {
                    const select = document.getElementById(selector);
                    const currentValue = select.value;
                    select.innerHTML = '<option value="" disabled selected>Select a column</option>';
                    if (columns.length === 0) {
                        errorDiv.textContent = 'No columns defined. Please add at least one column.';
                        return;
                    }
                    columns.forEach(col => {
                        const option = document.createElement('option');
                        option.value = col.name;
                        option.textContent = col.name;
                        if (col.name === currentValue) option.selected = true;
                        select.appendChild(option);
                    });
                });

                const patternColumns = document.getElementsByClassName('pattern-column');
                Array.from(patternColumns).forEach(select => {
                    const currentValue = select.value;
                    select.innerHTML = '<option value="" disabled selected>Select column</option>';
                    columns.forEach(col => {
                        const option = document.createElement('option');
                        option.value = col.name;
                        option.textContent = col.name;
                        if (col.name === currentValue) option.selected = true;
                        select.appendChild(option);
                    });
                    updatePatternInputs(select);
                });

                if (columns.length === 0) {
                    errorDiv.textContent = 'No columns defined. Please add at least one column.';
                } else {
                    errorDiv.textContent = '';
                }
            }

            function addColumn() {
                const errorDiv = document.getElementById('error');
                if (columns.length >= 20) {
                    errorDiv.textContent = 'Maximum 20 columns allowed.';
                    return;
                }
                const columnsDiv = document.getElementById('columns');
                const columnRow = document.createElement('div');
                columnRow.className = 'column-row';
                columnRow.innerHTML = `
                    <input type="text" class="column-name" placeholder="Column name (e.g., qty)">
                    <select class="column-type">
                        <option value="id">ID</option>
                        <option value="name">Name</option>
                        <option value="number">Number</option>
                        <option value="date">Date</option>
                    </select>
                    <span class="remove-btn">&times;</span>
                `;
                columnsDiv.appendChild(columnRow);
                columnRow.querySelector('.column-name').addEventListener('input', updateColumnSelectors);
                columnRow.querySelector('.column-type').addEventListener('change', updateColumnSelectors);
                columnRow.querySelector('.remove-btn').addEventListener('click', () => {
                    columnRow.remove();
                    updateColumnSelectors();
                });
                updateColumnSelectors();
            }

            function addScenarioPattern() {
                const patternsDiv = document.getElementById('scenario_patterns');
                const patternRow = document.createElement('div');
                patternRow.className = 'scenario-row';
                patternRow.innerHTML = `
                    <select class="pattern-column">
                        <option value="" disabled selected>Select column</option>
                    </select>
                    <select class="pattern-type">
                        <option value="normal">Normal Distribution</option>
                        <option value="categorical">Categorical</option>
                        <option value="uniform">Uniform (dates only)</option>
                    </select>
                    <div class="pattern-inputs">
                        <input type="number" class="pattern-mean" placeholder="Mean (e.g., 50)" required>
                        <input type="number" class="pattern-sd" placeholder="Std Dev (e.g., 10)" required>
                    </div>
                    <span class="remove-btn">&times;</span>
                `;
                patternsDiv.appendChild(patternRow);
                patternRow.querySelector('.pattern-column').addEventListener('change', () => updatePatternInputs(patternRow.querySelector('.pattern-column')));
                patternRow.querySelector('.pattern-type').addEventListener('change', () => updatePatternInputs(patternRow.querySelector('.pattern-type')));
                patternRow.querySelector('.remove-btn').addEventListener('click', () => {
                    patternRow.remove();
                    updateColumnSelectors();
                });
                updateColumnSelectors();
            }

            function addComputedField() {
                const computedFieldsDiv = document.getElementById('computed_fields');
                const computedFieldRow = document.createElement('div');
                computedFieldRow.className = 'computed-field-row';
                computedFieldRow.innerHTML = `
                    <input type="text" class="computed-field-name" placeholder="Field name (e.g., is_low_stock)">
                    <select class="computed-field-type">
                        <option value="number">Number</option>
                        <option value="boolean">Boolean</option>
                    </select>
                    <input type="text" class="computed-field-formula formula-input" placeholder="e.g., @qty * @rate or @qty < 10">
                    <span class="remove-btn">&times;</span>
                `;
                computedFieldsDiv.appendChild(computedFieldRow);
                computedFieldRow.querySelector('.computed-field-name').addEventListener('input', updateColumnSelectors);
                computedFieldRow.querySelector('.remove-btn').addEventListener('click', () => {
                    computedFieldRow.remove();
                    updateColumnSelectors();
                });
                updateColumnSelectors();
            }

            function addCondition() {
                const conditionsDiv = document.getElementById('conditions');
                const conditionRow = document.createElement('div');
                conditionRow.className = 'condition-row';
                conditionRow.innerHTML = `
                    <input type="text" class="condition-formula formula-input" placeholder="e.g., @qty > 10 or @is_low_stock">
                    <input type="text" class="condition-suggestion" placeholder="Suggestion (e.g., Low stock)">
                    <span class="remove-btn">&times;</span>
                `;
                conditionsDiv.appendChild(conditionRow);
                conditionRow.querySelector('.remove-btn').addEventListener('click', () => {
                    conditionRow.remove();
                    updateColumnSelectors();
                });
                updateColumnSelectors();
            }

            function updatePatternInputs(select) {
                const row = select.parentElement;
                const columnName = row.querySelector('.pattern-column').value;
                const column = columns.find(c => c.name === columnName);
                const patternType = row.querySelector('.pattern-type').value;
                const patternInputDiv = row.querySelector('.pattern-inputs');
                if (!column) {
                    patternInputDiv.innerHTML = '';
                    return;
                }
                if (column.type === 'date' || patternType === 'uniform') {
                    patternInputDiv.innerHTML = `
                        <input type="text" class="pattern-min" placeholder="Min date (optional)">
                        <input type="text" class="pattern-max" placeholder="Max date (optional)">
                    `;
                } else if (patternType === 'normal' && column.type === 'number') {
                    patternInputDiv.innerHTML = `
                        <input type="number" class="pattern-mean" placeholder="Mean (e.g., 50)" required>
                        <input type="number" class="pattern-sd" placeholder="Std Dev (e.g., 10)" required>
                    `;
                } else if (patternType === 'categorical' && (column.type === 'id' || column.type === 'name')) {
                    patternInputDiv.innerHTML = `
                        <input type="text" class="pattern-values" placeholder="Values:Probabilities (e.g., A:0.5,B:0.3,C:0.2)" required>
                    `;
                } else {
                    patternInputDiv.innerHTML = '<span style="color: red;">Invalid pattern for column type</span>';
                }
            }

            function validateInputs() {
                const errorDiv = document.getElementById('error');
                const rowCount = parseInt(document.getElementById('row_count').value) || 0;
                const dateRangeStart = document.getElementById('date_range_start').value;
                const dateRangeEnd = document.getElementById('date_range_end').value;
                const scenarioName = document.getElementById('scenario_name').value.trim();
                const currentDate = document.getElementById('current_date').value;
                const productIdCol = document.getElementById('product_id_col').value;
                const productNameCol = document.getElementById('product_name_col').value;

                if (rowCount < 1 || rowCount > 1000) {
                    errorDiv.textContent = 'Number of products must be between 1 and 1000.';
                    return false;
                }
                if (!dateRangeStart || !dateRangeEnd) {
                    errorDiv.textContent = 'Please specify date range start and end.';
                    return false;
                }
                if (new Date(dateRangeStart) > new Date(dateRangeEnd)) {
                    errorDiv.textContent = 'Start date must be before end date.';
                    return false;
                }
                if (columns.length === 0) {
                    errorDiv.textContent = 'Please define at least one column.';
                    return false;
                }
                if (columns.length > 20) {
                    errorDiv.textContent = 'Maximum 20 columns allowed.';
                    return false;
                }
                const columnNames = columns.map(col => col.name);
                const duplicates = columnNames.filter((name, index) => columnNames.indexOf(name) !== index);
                if (duplicates.length > 0) {
                    errorDiv.textContent = `Duplicate column names detected: ${duplicates.join(', ')}`;
                    return false;
                }
                if (!scenarioName) {
                    errorDiv.textContent = 'Please enter a scenario name.';
                    return false;
                }
                if (!currentDate) {
                    errorDiv.textContent = 'Please select a current date.';
                    return false;
                }
                if (!productIdCol || !productNameCol) {
                    errorDiv.textContent = 'Please select product ID and name columns.';
                    return false;
                }
                if (scenarios.some(s => s.name === scenarioName)) {
                    errorDiv.textContent = 'Scenario name must be unique.';
                    return false;
                }
                if (scenarios.length >= 5) {
                    errorDiv.textContent = 'Maximum 5 scenarios allowed. Delete one to add a new scenario.';
                    return false;
                }

                for (let pattern of scenarioPatterns) {
                    const column = columns.find(c => c.name === pattern.column);
                    if (!column) {
                        errorDiv.textContent = `Pattern references invalid column: ${pattern.column}`;
                        return false;
                    }
                    if (pattern.type === 'normal' && column.type === 'number') {
                        const mean = parseFloat(pattern.mean);
                        const sd = parseFloat(pattern.sd);
                        if (!pattern.mean || isNaN(mean)) {
                            errorDiv.textContent = `Mean for column ${pattern.column} must be a valid number.`;
                            return false;
                        }
                        if (!pattern.sd || isNaN(sd) || sd <= 0) {
                            errorDiv.textContent = `Standard deviation for column ${pattern.column} must be a positive number.`;
                            return false;
                        }
                    } else if (pattern.type === 'categorical' && (column.type === 'id' || column.type === 'name')) {
                        if (!pattern.values) {
                            errorDiv.textContent = `Categorical values for column ${pattern.column} cannot be empty.`;
                            return false;
                        }
                        const pairs = pattern.values.split(',').map(v => v.trim());
                        let totalProb = 0;
                        for (let pair of pairs) {
                            const [value, prob] = pair.split(':').map(v => v.trim());
                            if (!value || isNaN(parseFloat(prob)) || parseFloat(prob) < 0) {
                                errorDiv.textContent = `Invalid value:probability pair for column ${pattern.column}: ${pair}`;
                                return false;
                            }
                            totalProb += parseFloat(prob);
                        }
                        if (Math.abs(totalProb - 1) > 0.01) {
                            errorDiv.textContent = `Probabilities for column ${pattern.column} must sum to 1.`;
                            return false;
                        }
                    } else if (pattern.type === 'uniform' && column.type === 'date') {
                        if (pattern.min && isNaN(Date.parse(pattern.min))) {
                            errorDiv.textContent = `Invalid min date for column ${pattern.column}.`;
                            return false;
                        }
                        if (pattern.max && isNaN(Date.parse(pattern.max))) {
                            errorDiv.textContent = `Invalid max date for column ${pattern.column}.`;
                            return false;
                        }
                    } else {
                        errorDiv.textContent = `Invalid pattern type ${pattern.type} for column ${pattern.column} (${column.type}).`;
                        return false;
                    }
                }

                for (let field of computedFields) {
                    const error = validateFormulaColumns(field.formula, columns);
                    if (error) {
                        errorDiv.textContent = `Computed field ${field.name}: ${error}`;
                        return false;
                    }
                }

                const conditions = Array.from(document.getElementsByClassName('condition-row')).map(row => ({
                    formula: row.querySelector('.condition-formula').value.trim(),
                    suggestion: row.querySelector('.condition-suggestion').value.trim() || 'Dead stock condition'
                }));
                for (let cond of conditions) {
                    if (!cond.formula) {
                        errorDiv.textContent = 'Please provide a formula for all rules.';
                        return false;
                    }
                    const error = validateFormulaColumns(cond.formula, [...columns, ...computedFields]);
                    if (error) {
                        errorDiv.textContent = `Rule formula: ${error}`;
                        return false;
                    }
                }

                return true;
            }

            function generateData() {
                const errorDiv = document.getElementById('error');
                if (!validateInputs()) return null;

                const rowCount = parseInt(document.getElementById('row_count').value) || 100;
                const dateRangeStart = new Date(document.getElementById('date_range_start').value || '2024-01-01');
                const dateRangeEnd = new Date(document.getElementById('date_range_end').value || new Date());

                const data = [];
                for (let i = 0; i < rowCount; i++) {
                    const row = {};
                    columns.forEach(col => {
                        let value;
                        const pattern = scenarioPatterns.find(p => p.column === col.name);
                        if (pattern) {
                            if (pattern.type === 'normal' && col.type === 'number') {
                                const mean = parseFloat(pattern.mean);
                                const sd = parseFloat(pattern.sd);
                                value = randomNormal(mean, sd).toFixed(2);
                            } else if (pattern.type === 'categorical' && (col.type === 'id' || col.type === 'name')) {
                                const pairs = pattern.values.split(',').map(v => v.trim());
                                const values = pairs.map(p => p.split(':')[0]);
                                const probs = pairs.map(p => parseFloat(p.split(':')[1]));
                                let rand = Math.random();
                                let cumulative = 0;
                                for (let j = 0; j < probs.length; j++) {
                                    cumulative += probs[j];
                                    if (rand <= cumulative) {
                                        value = values[j];
                                        break;
                                    }
                                }
                            } else if (pattern.type === 'uniform' && col.type === 'date') {
                                const minDate = pattern.min ? new Date(pattern.min) : dateRangeStart;
                                const maxDate = pattern.max ? new Date(pattern.max) : dateRangeEnd;
                                const timeRange = maxDate - minDate;
                                const randomTime = minDate.getTime() + Math.random() * timeRange;
                                value = new Date(randomTime).toISOString().split('T')[0];
                            } else {
                                value = '';
                            }
                        } else {
                            if (col.type === 'id') value = `ID_${i + 1}`;
                            else if (col.type === 'name') value = `Product_${i + 1}`;
                            else if (col.type === 'number') value = (Math.random() * 100).toFixed(2);
                            else if (col.type === 'date') {
                                const timeRange = dateRangeEnd - dateRangeStart;
                                const randomTime = dateRangeStart.getTime() + Math.random() * timeRange;
                                value = new Date(randomTime).toISOString().split('T')[0];
                            }
                        }
                        row[col.name] = value;
                    });
                    data.push(row);
                }

                computedFields.forEach(field => {
                    data.forEach(row => {
                        try {
                            let result = evaluateFormula(field.formula, row, document.getElementById('current_date').value, columns, field.type);
                            if (field.type === 'boolean') {
                                row[field.name] = result ? 'Yes' : 'No';
                            } else {
                                row[field.name] = result;
                            }
                        } catch (e) {
                            errorDiv.textContent = `Error in computed field ${field.name}: ${e.message}`;
                            return null;
                        }
                    });
                });

                return data;
            }

            async function testScenario() {
                const errorDiv = document.getElementById('error');
                if (!validateInputs()) return;

                const scenarioName = document.getElementById('scenario_name').value.trim();
                const currentDate = document.getElementById('current_date').value;
                const productIdCol = document.getElementById('product_id_col').value;
                const productNameCol = document.getElementById('product_name_col').value;
                const rowCount = parseInt(document.getElementById('row_count').value) || 100;
                const dateRangeStart = document.getElementById('date_range_start').value;
                const dateRangeEnd = document.getElementById('date_range_end').value;

                const conditions = Array.from(document.getElementsByClassName('condition-row')).map(row => ({
                    formula: row.querySelector('.condition-formula').value.trim(),
                    suggestion: row.querySelector('.condition-suggestion').value.trim() || 'Dead stock condition'
                }));

                const data = generateData();
                if (!data) return;

                let results = [];
                data.forEach(row => {
                    let deadStockReason = '';
                    let deadStockCount = 0;
                    for (let cond of conditions) {
                        try {
                            const result = evaluateFormula(cond.formula, row, currentDate, [...columns, ...computedFields], 'boolean');
                            if (result) {
                                const cleanFormula = preprocessFormula(cond.formula);
                                const referencedColumns = cleanFormula.match(/[a-zA-Z_][a-zA-Z0-9_]*/g) || [];
                                const primaryColumn = referencedColumns.find(col => 
                                    [...columns, ...computedFields].some(c => c.name === col)
                                );
                                if (primaryColumn && row[primaryColumn] && !isNaN(parseFloat(row[primaryColumn]))) {
                                    deadStockCount = parseFloat(row[primaryColumn]);
                                } else {
                                    deadStockCount = 1;
                                }
                                deadStockReason = cond.suggestion;
                                break;
                            }
                        } catch (e) {
                            errorDiv.textContent = `Rule error: ${e.message}`;
                            return;
                        }
                    }

                    if (deadStockReason) {
                        results.push({
                            scenario: scenarioName,
                            productId: row[productIdCol] || `ID_${results.length + 1}`,
                            productName: row[productNameCol] || `Product_${results.length + 1}`,
                            deadStockCount,
                            deadStockReason
                        });
                    }
                });

                // Save user inputs as JSON to Google Form
                const scenarioInputs = {
                    name: scenarioName,
                    rowCount: rowCount,
                    dateRangeStart: dateRangeStart,
                    dateRangeEnd: dateRangeEnd,
                    currentDate: currentDate,
                    productIdCol: productIdCol,
                    productNameCol: productNameCol,
                    columns: columns,
                    scenarioPatterns: scenarioPatterns,
                    computedFields: computedFields,
                    conditions: conditions
                };

                const jsonContent = JSON.stringify(scenarioInputs, null, 2);
                const saved = await saveToGoogleForm(jsonContent);
                if (!saved) {
                    // Fallback: Download JSON locally
                    const blob = new Blob([jsonContent], { type: 'application/json' });
                    const link = document.createElement('a');
                    link.href = URL.createObjectURL(blob);
                    link.download = `${scenarioName}.json`;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                }

                scenarios.push({
                    name: scenarioName,
                    data,
                    results,
                    columns,
                    computedFields,
                    scenarioPatterns,
                    conditions,
                    productIdCol,
                    productNameCol
                });

                const scenarioList = document.getElementById('scenarioList');
                scenarioList.innerHTML = '';
                scenarios.forEach((scenario, index) => {
                    const scenarioItem = document.createElement('div');
                    scenarioItem.className = 'scenario-item';
                    scenarioItem.innerHTML = `
                        ${scenario.name}
                        <button class="delete-scenario-btn" data-index="${index}">Delete</button>
                    `;
                    scenarioList.appendChild(scenarioItem);
                    scenarioItem.querySelector('.delete-scenario-btn').addEventListener('click', () => deleteScenario(index));
                });

                document.getElementById('results').style.display = 'block';
                const resultsBody = document.getElementById('resultsBody');
                resultsBody.innerHTML = '';
                if (results.length === 0) {
                    resultsBody.innerHTML = '<tr><td colspan="5">No dead stock found</td></tr>';
                } else {
                    results.forEach(result => {
                        const row = document.createElement('tr');
                        row.innerHTML = `
                            <td>${result.scenario}</td>
                            <td>${result.productId}</td>
                            <td>${result.productName}</td>
                            <td class="${result.deadStockCount > 0 ? 'red' : ''}">${result.deadStockCount}</td>
                            <td>${result.deadStockReason}</td>
                        `;
                        resultsBody.appendChild(row);
                    });
                }

                errorDiv.textContent = saved ? 'Scenario tested successfully and saved to Google Form!' : 'Scenario tested successfully, but saved locally due to Google Form error.';
                setTimeout(() => { errorDiv.textContent = ''; }, 3000);
            }

            function deleteScenario(index) {
                scenarios.splice(index, 1);
                const scenarioList = document.getElementById('scenarioList');
                scenarioList.innerHTML = '';
                scenarios.forEach((scenario, i) => {
                    const scenarioItem = document.createElement('div');
                    scenarioItem.className = 'scenario-item';
                    scenarioItem.innerHTML = `
                        ${scenario.name}
                        <button class="delete-scenario-btn" data-index="${i}">Delete</button>
                    `;
                    scenarioList.appendChild(scenarioItem);
                    scenarioItem.querySelector('.delete-scenario-btn').addEventListener('click', () => deleteScenario(i));
                });

                const resultsBody = document.getElementById('resultsBody');
                resultsBody.innerHTML = '';
                scenarios.forEach(scenario => {
                    scenario.results.forEach(result => {
                        const row = document.createElement('tr');
                        row.innerHTML = `
                            <td>${result.scenario}</td>
                            <td>${result.productId}</td>
                            <td>${result.productName}</td>
                            <td class="${result.deadStockCount > 0 ? 'red' : ''}">${result.deadStockCount}</td>
                            <td>${result.deadStockReason}</td>
                        `;
                        resultsBody.appendChild(row);
                    });
                });
                if (scenarios.length === 0) {
                    document.getElementById('results').style.display = 'none';
                    resultsBody.innerHTML = '<tr><td colspan="5">No scenarios created yet</td></tr>';
                }
            }

            function downloadResults() {
                if (scenarios.length === 0) {
                    document.getElementById('error').textContent = 'No scenarios to download.';
                    return;
                }

                let csvContent = 'Scenario,Product ID,Product Name,Dead Stock Count,Dead Stock Reason\n';
                scenarios.forEach(scenario => {
                    scenario.results.forEach(result => {
                        csvContent += `"${result.scenario}","${result.productId}","${result.productName}",${result.deadStockCount},"${result.deadStockReason}"\n`;
                    });
                });

                const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement('a');
                const url = URL.createObjectURL(blob);
                link.setAttribute('href', url);
                link.setAttribute('download', 'stocksync_results.csv');
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }

            function initializeInterface() {
                console.log('Initializing interface');
                document.getElementById('results').style.display = 'none';
                document.getElementById('scenarioList').innerHTML = '';
                document.getElementById('resultsBody').innerHTML = '<tr><td colspan="5">No scenarios created yet</td></tr>';
                document.getElementById('error').textContent = '';

                document.getElementById('add-column-btn').addEventListener('click', addColumn);
                document.getElementById('add-scenario-pattern-btn').addEventListener('click', addScenarioPattern);
                document.getElementById('add-computed-field-btn').addEventListener('click', addComputedField);
                document.getElementById('add-condition-btn').addEventListener('click', addCondition);
                document.getElementById('test-scenario-btn').addEventListener('click', testScenario);
                document.getElementById('download-results-btn').addEventListener('click', downloadResults);

                addColumn();
                addScenarioPattern();
                addComputedField();
                addCondition();
                updateColumnSelectors();
            }

            initializeInterface();
        });
    </script>
</body>
</html>